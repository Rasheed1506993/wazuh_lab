# Wazuh Indexer
## Comprehensive Report on Storage and Indexing Mechanism in Wazuh EDR System

---

## Table of Contents

1. [Introduction](#1-introduction)
2. [Data Reception](#2-data-reception)
3. [Index Templates](#3-index-templates)
4. [Mappings (Data Schema)](#4-mappings-data-schema)
5. [Indexing Process](#5-indexing-process)
6. [Search Process](#6-search-process)
7. [Libraries and Tools](#7-libraries-and-tools)
8. [Complete Data Flow](#8-complete-data-flow)
9. [Diagrams](#9-diagrams)
10. [Practical Examples](#10-practical-examples)
11. [Challenges and Solutions](#11-challenges-and-solutions)
12. [Monitoring & Troubleshooting](#12-monitoring--troubleshooting)
13. [Conclusion](#13-conclusion)

---

## 1. Introduction

### 1.1 What is Wazuh Indexer?

The Wazuh indexer is a real-time, full-text search and analytics engine for security data, built on OpenSearch (a fork of Elasticsearch 7.10.2). It serves as the primary component responsible for indexing and storing all security events and alerts generated by the Wazuh server, enabling fast search and deep analysis of security data.

### 1.2 Role in the Wazuh Ecosystem

The indexer functions as the persistent storage layer in the Wazuh architecture:

- **Receives** thousands of security events and alerts from the Wazuh server via Filebeat
- **Indexes** data in an organized manner enabling rapid search through millions of records
- **Provides** a RESTful API for querying and analyzing data
- **Supports** the Wazuh dashboard in displaying alerts and security statistics
- **Retains** historical data for forensic analysis and compliance

### 1.3 Why OpenSearch?

OpenSearch was selected for several technical reasons:

1. **Full-Text Search**: Apache Lucene engine provides extremely fast search capabilities
2. **Horizontal Scaling**: Ability to distribute data across multiple nodes
3. **High Availability**: Automatic replica copies ensure no data loss
4. **Aggregations**: Advanced analytical capabilities
5. **Open Source**: Community-supported with active development

---

## 2. Data Reception

### 2.1 Data Path from Wazuh Server to Indexer

```mermaid
graph TD
    A[Wazuh Manager<br/>analysisd] -->|Writes| B[alerts.json]
    B -->|Monitors| C[Filebeat<br/>Log Shipper]
    C -->|HTTP/HTTPS| D[Wazuh Indexer<br/>OpenSearch]
    
    style A fill:#e1f5ff
    style B fill:#fff4e6
    style C fill:#e8f5e9
    style D fill:#f3e5f5
```

### 2.2 Filebeat Role

Filebeat is a lightweight log shipper that performs the following functions:

**Primary Functions:**
- **Continuous Monitoring**: Monitors `/var/ossec/logs/alerts/alerts.json`
- **Smart Reading**: Tracks last read position to avoid duplication (registry file)
- **Secure Transmission**: Uses TLS encryption during transport
- **Retry Logic**: Automatically retries on failure
- **Compression**: Compresses data before sending to save bandwidth

**Basic Configuration File** (`/etc/filebeat/filebeat.yml`):

```yaml
filebeat.modules:
  - module: wazuh
    alerts:
      enabled: true
    archives:
      enabled: false

output.elasticsearch:
  hosts: ["https://indexer:9200"]
  protocol: "https"
  username: "admin"
  password: "${INDEXER_PASSWORD}"
  ssl.certificate_authorities: ["/etc/filebeat/certs/root-ca.pem"]
  
  # Bulk settings
  bulk_max_size: 2048
  worker: 4
```

### 2.3 Data Format (JSON Structure)

**Example of an actual security alert:**

```json
{
  "timestamp": "2025-10-19T14:30:45.123+0000",
  "rule": {
    "level": 10,
    "description": "Possible SSH brute force attack",
    "id": "5551",
    "firedtimes": 5,
    "mail": true,
    "groups": ["syslog", "sshd", "authentication_failed"]
  },
  "agent": {
    "id": "001",
    "name": "web-server-01",
    "ip": "192.168.1.100"
  },
  "manager": {
    "name": "wazuh-manager"
  },
  "data": {
    "srcip": "203.0.113.45",
    "srcport": "54321",
    "dstuser": "root"
  },
  "decoder": {
    "name": "sshd"
  },
  "location": "/var/log/auth.log",
  "full_log": "Failed password for root from 203.0.113.45 port 54321 ssh2"
}
```

### 2.4 Protocol and Format

- **Protocol**: HTTPS (TLS 1.2+)
- **Method**: POST to `/_bulk` API
- **Format**: NDJSON (Newline Delimited JSON)
- **Authentication**: Basic Authentication or API Key
- **Transmission Rate**: Batch processing (batches of 500-2000 documents)

---

## 3. Index Templates

### 3.1 What are Index Templates?

Index templates are definitional schemas that determine how new indices are automatically created. When a new document arrives, the indexer checks the index name, and if it doesn't exist, creates it using the matching template.

### 3.2 Template Location in Code

In Wazuh Indexer, templates are located in:

```
wazuh-indexer/
└── integrations/
    └── filebeat/
        └── wazuh-template.json    # ⭐ Very important
```

### 3.3 Example: wazuh-alerts Template

```json
{
  "index_patterns": ["wazuh-alerts-4.x-*"],
  "priority": 1,
  "template": {
    "settings": {
      "index": {
        "number_of_shards": 3,
        "number_of_replicas": 1,
        "refresh_interval": "5s",
        "codec": "best_compression",
        "max_result_window": 100000,
        "mapping": {
          "total_fields": {
            "limit": 10000
          }
        }
      }
    },
    "mappings": {
      "properties": {
        "@timestamp": {
          "type": "date",
          "format": "strict_date_optional_time||epoch_millis"
        },
        "rule": {
          "properties": {
            "id": {"type": "keyword"},
            "level": {"type": "long"},
            "description": {"type": "text"}
          }
        }
      }
    }
  }
}
```

### 3.4 Important Settings Explained

#### Settings:

| Setting | Value | Purpose |
|---------|-------|---------|
| `number_of_shards` | 3 | Number of parts the index is divided into for distribution |
| `number_of_replicas` | 1 | Number of backup copies for each shard |
| `refresh_interval` | 5s | Rate at which the index is refreshed to make new data searchable |
| `codec` | best_compression | Data compression to save storage space |
| `max_result_window` | 100000 | Maximum number of results in a single query |

#### Index Patterns:

- `wazuh-alerts-4.x-*` matches indices such as:
  - `wazuh-alerts-4.x-2025.10.19`
  - `wazuh-alerts-4.x-2025.10.20`
  
This allows creating a new index daily (Index Rotation) to improve performance and ease management.

---

## 4. Mappings (Data Schema)

### 4.1 What are Mappings?

Mappings are schemas that define the data structure in an index, including:
- Type of each field (field type)
- How it's indexed (indexing strategy)
- How text is analyzed (text analysis)

### 4.2 Key Fields in Wazuh Alerts

#### 4.2.1 Timestamp Fields

```json
"@timestamp": {
  "type": "date",
  "format": "strict_date_optional_time||epoch_millis"
}
```

- **Type**: `date`
- **Purpose**: Store alert occurrence time
- **Format**: Accepts ISO 8601 or Unix timestamp
- **Importance**: Essential for time-based filtering and charts

#### 4.2.2 Rule Fields

```json
"rule": {
  "properties": {
    "id": {
      "type": "keyword",
      "ignore_above": 256
    },
    "level": {
      "type": "long"
    },
    "description": {
      "type": "text",
      "fields": {
        "keyword": {
          "type": "keyword",
          "ignore_above": 256
        }
      }
    },
    "groups": {
      "type": "keyword"
    },
    "mitre": {
      "properties": {
        "id": {"type": "keyword"},
        "tactic": {"type": "keyword"},
        "technique": {"type": "keyword"}
      }
    }
  }
}
```

**Explanation:**

- **`rule.id`**: Rule identifier (e.g., "5551")
  - Type `keyword` for exact search and aggregations
  
- **`rule.level`**: Severity level (0-15)
  - Type `long` for numeric comparisons
  
- **`rule.description`**: Alert description
  - Type `text` for full-text search
  - Sub-field `keyword` for sorting and aggregations
  
- **`rule.groups`**: Rule categories
  - Type `keyword` array for filtering

#### 4.2.3 Agent Fields

```json
"agent": {
  "properties": {
    "id": {"type": "keyword"},
    "name": {"type": "keyword"},
    "ip": {"type": "ip"},
    "version": {"type": "keyword"},
    "os": {
      "properties": {
        "platform": {"type": "keyword"},
        "version": {"type": "keyword"},
        "name": {"type": "text"}
      }
    }
  }
}
```

**Explanation:**

- **`agent.ip`**: Special type `ip` allowing:
  - CIDR range searches (e.g., 192.168.1.0/24)
  - Smart sorting and aggregation of addresses

#### 4.2.4 Raw Data Fields

```json
"data": {
  "type": "object",
  "dynamic": true
}
```

- **Dynamic Mapping**: Allows automatic addition of new fields
- **Purpose**: Store data specific to each decoder
- **Flexibility**: Each event type has different fields

### 4.3 Difference Between Text and Keyword

| Feature | Text | Keyword |
|---------|------|---------|
| **Indexing** | Analyzes text into tokens | Stored as-is (exact value) |
| **Search** | Full-text search | Exact match |
| **Usage** | Descriptions, long messages | IDs, categories, names |
| **Aggregations** | ❌ Not suitable | ✅ Perfect |
| **Sorting** | ❌ Not suitable | ✅ Fast |

**Example:**

```json
"rule.description": "Possible SSH brute force attack"
```

- As **text**: Indexed as ["possible", "ssh", "brute", "force", "attack"]
  - Can search for "brute force" and find results
  
- As **keyword**: Indexed as "Possible SSH brute force attack"
  - Must search exact complete text

### 4.4 Complete Simplified Mapping

```json
{
  "mappings": {
    "properties": {
      "@timestamp": {"type": "date"},
      "rule": {
        "properties": {
          "id": {"type": "keyword"},
          "level": {"type": "long"},
          "description": {"type": "text", "fields": {"keyword": {"type": "keyword"}}},
          "groups": {"type": "keyword"},
          "firedtimes": {"type": "long"}
        }
      },
      "agent": {
        "properties": {
          "id": {"type": "keyword"},
          "name": {"type": "keyword"},
          "ip": {"type": "ip"}
        }
      },
      "data": {
        "properties": {
          "srcip": {"type": "ip"},
          "dstip": {"type": "ip"},
          "srcport": {"type": "long"},
          "dstport": {"type": "long"},
          "srcuser": {"type": "keyword"},
          "dstuser": {"type": "keyword"},
          "protocol": {"type": "keyword"}
        }
      },
      "location": {"type": "keyword"},
      "full_log": {"type": "text"},
      "decoder": {
        "properties": {
          "name": {"type": "keyword"},
          "parent": {"type": "keyword"}
        }
      }
    }
  }
}
```

---

## 5. Indexing Process

### 5.1 Document Storage Steps

```mermaid
graph TD
    A[Document Arrival] --> B[Routing]
    B --> C[Template Matching]
    C --> D[Mapping Application]
    D --> E[Analysis]
    E --> F[Indexing]
    F --> G[Replication]
    G --> H[Response]
    
    B -->|Calculate Shard ID| B1[from document ID]
    C -->|Select Template| C1[appropriate]
    D -->|Apply schema| D1[to fields]
    E -->|Text analysis| E1[tokenization]
    F -->|Write to| F1[Lucene segments]
    G -->|Copy to| G1[Replica shards]
    H -->|Return| H1[Success/Failure]
    
    style A fill:#e3f2fd
    style H fill:#c8e6c9
```

### 5.2 Data Processing (Ingest Pipelines)

Wazuh uses pipelines to enrich data before storage:

```json
{
  "description": "Wazuh alerts enrichment pipeline",
  "processors": [
    {
      "set": {
        "field": "event.kind",
        "value": "alert"
      }
    },
    {
      "set": {
        "field": "event.module",
        "value": "wazuh"
      }
    },
    {
      "date": {
        "field": "timestamp",
        "target_field": "@timestamp",
        "formats": ["ISO8601"]
      }
    },
    {
      "geoip": {
        "field": "data.srcip",
        "target_field": "data.srcgeoip",
        "ignore_missing": true
      }
    },
    {
      "script": {
        "source": "ctx.event.severity = ctx.rule.level"
      }
    }
  ]
}
```

**Explanation:**
- **set**: Add fixed fields
- **date**: Convert date to unified format
- **geoip**: Add geographic information for IP addresses
- **script**: Execute custom code for data processing

### 5.3 APIs Used

#### 5.3.1 Index API (Single Document)

```http
POST /wazuh-alerts-4.x-2025.10.19/_doc
Content-Type: application/json

{
  "@timestamp": "2025-10-19T14:30:45.123Z",
  "rule": {
    "id": "5551",
    "level": 10,
    "description": "SSH brute force"
  },
  "agent": {
    "name": "server-01"
  }
}
```

**Response:**
```json
{
  "_index": "wazuh-alerts-4.x-2025.10.19",
  "_id": "Abc123def456",
  "_version": 1,
  "result": "created",
  "_shards": {
    "total": 2,
    "successful": 2,
    "failed": 0
  }
}
```

#### 5.3.2 Bulk API (Multiple Documents)

Filebeat uses Bulk API to send batches:

```http
POST /_bulk
Content-Type: application/x-ndjson

{"index":{"_index":"wazuh-alerts-4.x-2025.10.19"}}
{"@timestamp":"2025-10-19T14:30:45Z","rule":{"id":"5551","level":10}}
{"index":{"_index":"wazuh-alerts-4.x-2025.10.19"}}
{"@timestamp":"2025-10-19T14:30:46Z","rule":{"id":"5502","level":3}}
```

**Bulk API Advantages:**
- Reduces network overhead (one call instead of thousands)
- Improves throughput by up to 10x
- Atomic operations ensure data consistency

### 5.4 Example Code: Python Client

```python
from opensearchpy import OpenSearch

# Connect to indexer
client = OpenSearch(
    hosts=['https://indexer:9200'],
    http_auth=('admin', 'password'),
    use_ssl=True,
    verify_certs=True,
    ca_certs='/path/to/root-ca.pem'
)

# Index a single document
response = client.index(
    index='wazuh-alerts-4.x-2025.10.19',
    body={
        '@timestamp': '2025-10-19T14:30:45.123Z',
        'rule': {
            'id': '5551',
            'level': 10,
            'description': 'SSH brute force attempt'
        },
        'agent': {
            'name': 'web-server-01',
            'ip': '192.168.1.100'
        },
        'data': {
            'srcip': '203.0.113.45',
            'dstuser': 'root'
        }
    }
)

print(f"Document indexed with ID: {response['_id']}")
```

---

## 6. Search Process

### 6.1 How Does Search Work?

The search process goes through multiple phases:

```mermaid
graph TD
    A[Query Reception] --> B[Query Parsing]
    B --> C[Shard Selection]
    C --> D[Scatter Phase]
    D --> E[Local Search]
    E --> F[Gather Phase]
    F --> G[Sorting & Ranking]
    G --> H[Response]
    
    A -->|Receive query| A1[from Client]
    B -->|Parse| B1[Query DSL]
    C -->|Select| C1[Shards to search]
    D -->|Send Query| D1[to each Shard]
    E -->|Each Shard| E1[searches locally]
    F -->|Collect results| F1[from all Shards]
    G -->|Sort results| G1[by relevance]
    H -->|Return| H1[Top results]
    
    style A fill:#e1f5ff
    style H fill:#c8e6c9
```

### 6.2 Query DSL (Domain Specific Language)

OpenSearch uses a JSON-based query language:

#### 6.2.1 Match Query (text search)

```json
{
  "query": {
    "match": {
      "rule.description": "brute force"
    }
  }
}
```

#### 6.2.2 Term Query (exact search)

```json
{
  "query": {
    "term": {
      "rule.id": "5551"
    }
  }
}
```

#### 6.2.3 Range Query (time range)

```json
{
  "query": {
    "range": {
      "@timestamp": {
        "gte": "2025-10-19T00:00:00",
        "lt": "2025-10-20T00:00:00"
      }
    }
  }
}
```

#### 6.2.4 Bool Query (compound query)

```json
{
  "query": {
    "bool": {
      "must": [
        {"range": {"rule.level": {"gte": 7}}}
      ],
      "filter": [
        {"term": {"agent.name": "web-server-01"}},
        {"range": {"@timestamp": {"gte": "now-24h"}}}
      ],
      "must_not": [
        {"term": {"rule.groups": "test"}}
      ]
    }
  },
  "size": 100,
  "sort": [
    {"@timestamp": "desc"}
  ]
}
```

**Explanation:**
- **must**: Required conditions (affect relevance score)
- **filter**: Filtering (doesn't affect scoring, faster)
- **must_not**: Exclude results
- **should**: Optional conditions (improve score)

### 6.3 Common Query Examples

#### Example 1: High severity alerts in last hour

```json
{
  "query": {
    "bool": {
      "filter": [
        {"range": {"rule.level": {"gte": 10}}},
        {"range": {"@timestamp": {"gte": "now-1h"}}}
      ]
    }
  },
  "sort": [{"@timestamp": "desc"}],
  "size": 50
}
```

#### Example 2: SSH attacks from specific IP

```json
{
  "query": {
    "bool": {
      "must": [
        {"match": {"rule.groups": "sshd"}},
        {"term": {"data.srcip": "203.0.113.45"}}
      ]
    }
  },
  "aggs": {
    "attacks_over_time": {
      "date_histogram": {
        "field": "@timestamp",
        "fixed_interval": "1h"
      }
    }
  }
}
```

#### Example 3: Top 10 agents with alerts

```json
{
  "size": 0,
  "aggs": {
    "top_agents": {
      "terms": {
        "field": "agent.name",
        "size": 10,
        "order": {"_count": "desc"}
      },
      "aggs": {
        "avg_severity": {
          "avg": {"field": "rule.level"}
        }
      }
    }
  }
}
```

### 6.4 Aggregations

Aggregations are powerful features for analysis:

#### Aggregation Types:

1. **Metric Aggregations**: Numeric calculations
   - `avg`, `sum`, `min`, `max`, `stats`
   
2. **Bucket Aggregations**: Data grouping
   - `terms`, `date_histogram`, `range`
   
3. **Pipeline Aggregations**: Process results of other aggregations
   - `derivative`, `cumulative_sum`, `moving_avg`

**Example: Daily alert statistics**

```json
{
  "size": 0,
  "aggs": {
    "alerts_per_day": {
      "date_histogram": {
        "field": "@timestamp",
        "calendar_interval": "1d"
      },
      "aggs": {
        "severity_stats": {
          "stats": {"field": "rule.level"}
        },
        "top_rules": {
          "terms": {
            "field": "rule.id",
            "size": 5
          }
        }
      }
    }
  }
}
```

### 6.5 Search APIs Used

#### Search API

```http
POST /wazuh-alerts-*/_search
Content-Type: application/json

{
  "query": {...},
  "size": 100,
  "from": 0,
  "sort": [{"@timestamp": "desc"}],
  "_source": ["rule.*", "agent.name", "@timestamp"]
}
```

**Parameters:**
- `size`: Number of results (default: 10)
- `from`: offset for pagination
- `_source`: Fields to return
- `sort`: Result ordering

#### Multi-Search API

To search multiple indices at once:

```http
POST /_msearch
Content-Type: application/x-ndjson

{"index":"wazuh-alerts-*"}
{"query":{"match":{"rule.level":10}}}
{"index":"wazuh-archives-*"}
{"query":{"term":{"agent.name":"server-01"}}}
```

---

## 7. Libraries and Tools

### 7.1 OpenSearch Version

Wazuh Indexer uses:
- **OpenSearch 2.x** (currently 2.11.x)
- Built on **Apache Lucene 9.x**
- Compatible with Elasticsearch 7.10.2 APIs

### 7.2 Filebeat Configuration

**Basic Settings:**

```yaml
# /etc/filebeat/filebeat.yml

filebeat.modules:
  - module: wazuh
    alerts:
      enabled: true
      var.input: file
      var.paths: ["/var/ossec/logs/alerts/alerts.json"]
    archives:
      enabled: false

output.elasticsearch:
  hosts: ["https://wazuh-indexer:9200"]
  protocol: "https"
  username: "admin"
  password: "${ELASTIC_PASSWORD}"
  
  # TLS
  ssl.certificate_authorities: ["/etc/filebeat/certs/root-ca.pem"]
  ssl.certificate: "/etc/filebeat/certs/filebeat.pem"
  ssl.key: "/etc/filebeat/certs/filebeat-key.pem"
  
  # Performance
  bulk_max_size: 2048
  worker: 4
  compression_level: 3
  
  # Index settings
  index: "wazuh-alerts-4.x-%{+yyyy.MM.dd}"
  
  # Retry
  max_retries: 3
  backoff.init: 1s
  backoff.max: 60s

# Processors
processors:
  - drop_fields:
      fields: ["ecs.version", "host.name", "input.type"]
  - rename:
      fields:
        - {from: "timestamp", to: "@timestamp"}
  - timestamp:
      field: "@timestamp"
      layouts:
        - "2006-01-02T15:04:05.999Z"
```

### 7.3 Security Features

#### Authentication Methods:

1. **Basic Authentication**
```bash
curl -u admin:password https://indexer:9200/_cluster/health
```

2. **API Keys**
```bash
# Create API key
POST /_security/api_key
{
  "name": "filebeat-key",
  "role_descriptors": {
    "filebeat_writer": {
      "cluster": ["monitor"],
      "index": [
        {
          "names": ["wazuh-alerts-*"],
          "privileges": ["create_index", "write", "create"]
        }
      ]
    }
  }
}
```

#### TLS/SSL Configuration:

```yaml
# opensearch.yml
plugins.security.ssl.transport.pemcert_filepath: node-cert.pem
plugins.security.ssl.transport.pemkey_filepath: node-key.pem
plugins.security.ssl.transport.pemtrustedcas_filepath: root-ca.pem
plugins.security.ssl.transport.enforce_hostname_verification: false

plugins.security.ssl.http.enabled: true
plugins.security.ssl.http.pemcert_filepath: node-cert.pem
plugins.security.ssl.http.pemkey_filepath: node-key.pem
plugins.security.ssl.http.pemtrustedcas_filepath: root-ca.pem
```

#### Role-Based Access Control (RBAC):

```json
{
  "wazuh_user": {
    "cluster_permissions": ["cluster_monitor"],
    "index_permissions": [
      {
        "index_patterns": ["wazuh-alerts-*", "wazuh-archives-*"],
        "allowed_actions": ["read", "search"]
      }
    ]
  }
}
```

### 7.4 Additional Tools

| Tool | Purpose | Repository |
|------|---------|----------|
| **opensearch-cli** | Command-line administration tool | github.com/opensearch-project/opensearch-cli |
| **Index State Management (ISM)** | Index lifecycle management | Built into OpenSearch |
| **Performance Analyzer** | Cluster performance analysis | Built into OpenSearch |
| **Anomaly Detection** | AI-powered anomaly detection | Plugin |

---

## 8. Complete Data Flow

### 8.1 From Wazuh Server to Final Storage

```mermaid
sequenceDiagram
    participant M as Wazuh Manager
    participant F as alerts.json
    participant FB as Filebeat
    participant I as Indexer
    participant R as Replica
    
    M->>F: Write Alert
    FB->>F: Read File
    FB->>I: POST /_bulk
    I->>I: Apply Template
    I->>I: Apply Mapping
    I->>I: Index Document
    I->>R: Replicate
    R-->>I: ACK
    I-->>FB: 200 OK
```

### 8.2 Detailed Explanation of Each Phase

#### Phase 1: Alert Generation in Manager

```
1. analysisd reads event from Agent
2. Matches against rules
3. If matched → generates alert
4. Enriches with additional information:
   - Agent information
   - MITRE ATT&CK classification
   - GeoIP lookup
5. Writes to alerts.json as JSON line
```

**Timing**: ~1-5ms per event

#### Phase 2: Reading by Filebeat

```
1. Harvester monitors alerts.json
2. Reads new line (JSON)
3. Saves position in registry file
4. Sends to Processor
```

**Timing**: ~10-100ms latency

#### Phase 3: Processing and Sending

```
1. Processor applies filters:
   - Remove unimportant fields
   - Rename fields
   - Add metadata
2. Publisher collects events in batch
3. Compresses data (gzip)
4. Sends POST /_bulk
```

**Batch Size**: 500-2000 documents
**Timing**: ~100-500ms per batch

#### Phase 4: Indexing in Indexer

```
1. Coordinator receives bulk request
2. Parses each document:
   - Determines target index
   - Calculates shard ID
3. Sends to appropriate Primary shard
4. Primary shard:
   - Applies template (if new index)
   - Applies mapping
   - Executes ingest pipeline
   - Writes to Lucene segments
   - Sends to replicas
5. Waits for acknowledgment from replicas
6. Responds with success/failure
```

**Timing**: ~50-200ms per batch

#### Phase 5: Search and Query

```
1. Client sends search query
2. Coordinator:
   - Determines target indices
   - Selects shard from each index
3. Sends query in parallel to each shard
4. Each shard:
   - Executes query locally
   - Sorts results
   - Returns top N results
5. Coordinator:
   - Merges results
   - Sorts globally
   - Returns final response
```

**Timing**: ~10-1000ms depending on complexity

### 8.3 Complete Timeline Example

```
T+0ms     : Agent detects file change
T+5ms     : Manager receives event
T+10ms    : analysisd matches rule 5551
T+15ms    : Writes alert to alerts.json
T+115ms   : Filebeat reads new line
T+120ms   : Adds to batch
T+620ms   : Batch full (2000 docs) → Send
T+720ms   : Indexer receives and starts indexing
T+820ms   : Indexer completes writing
T+825ms   : Filebeat receives acknowledgment
T+5000ms  : Refresh interval → Document searchable
T+5100ms  : Dashboard searches and displays alert
```

**Total Latency**: ~5 seconds from event to display

---

## 9. Diagrams

### 9.1 Sequence Diagram: Storage Flow

```mermaid
sequenceDiagram
    participant M as Manager
    participant FB as Filebeat
    participant I as Indexer
    participant R as Replica
    
    M->>M: Write Alert
    FB->>M: Read File
    FB->>I: POST /_bulk
    I->>I: Apply Template
    I->>I: Apply Mapping
    I->>I: Index Document
    I->>R: Replicate
    R->>I: ACK
    I->>FB: 200 OK
```

### 9.2 Sequence Diagram: Search Flow

```mermaid
sequenceDiagram
    participant D as Dashboard
    participant API as Wazuh API
    participant I as Indexer
    participant S as Shards
    
    D->>API: GET /alerts
    API->>I: POST /_search
    I->>I: Parse Query
    I->>S: Scatter
    S->>S: Search
    S->>I: Results
    I->>I: Merge & Sort
    I->>API: Response
    API->>D: JSON Results
    D->>D: Render UI
```

### 9.3 Component/Architecture Diagram

```
graph TB
    subgraph DP["DATA PRODUCERS"]
        Agent["Wazuh Agent<br/>(Hosts)"]
        Manager["Wazuh Manager<br/>(analysisd)"]
        Files["alerts.json<br/>archives.json"]
        
        Agent -->|TCP 1514| Manager
        Manager -->|writes| Files
    end
    
    subgraph LS["LOG SHIPPING"]
        subgraph FB["Filebeat"]
            Harvester["Harvester"]
            Processor["Processor"]
            Publisher["Bulk Publisher"]
            
            Harvester --> Processor
            Processor --> Publisher
        end
    end
    
    Files -->|monitors| Harvester
    
    subgraph WIC["WAZUH INDEXER CLUSTER"]
        Coordinator["Coordinator Node (Master)<br/>- Cluster Management<br/>- Request Routing<br/>- Index/Template Management"]
        
        subgraph DN1["Data Node 1"]
            S0P["Shard 0<br/>(Primary)"]
            S1R["Shard 1<br/>(Replica)"]
        end
        
        subgraph DN2["Data Node 2"]
            S1P["Shard 1<br/>(Primary)"]
            S2R["Shard 2<br/>(Replica)"]
        end
        
        subgraph DN3["Data Node 3"]
            S2P["Shard 2<br/>(Primary)"]
            S0R["Shard 0<br/>(Replica)"]
        end
        
        Templates["Index Templates<br/>- wazuh-alerts-template<br/>- wazuh-archives-template"]
        
        Indices["Indices<br/>- wazuh-alerts-4.x-2025.10.19<br/>- wazuh-alerts-4.x-2025.10.18<br/>- wazuh-archives-4.x-2025.10.19"]
        
        Coordinator --> DN1
        Coordinator --> DN2
        Coordinator --> DN3
    end
    
    Publisher -->|HTTPS /_bulk| Coordinator
    
    subgraph DC["DATA CONSUMERS"]
        API["Wazuh API<br/>(Backend)"]
        Dashboard["Wazuh Dashboard<br/>(Frontend)"]
        
        Dashboard -->|queries| API
    end
    
    Coordinator -->|REST API| API
    
    API -->|GET /_search<br/>POST /_msearch<br/>GET /_count| Coordinator
    
    subgraph Legend["KEY COMPONENTS"]
        L1["Shards: Data partitions for horizontal scaling"]
        L2["Replicas: Backup copies for high availability"]
        L3["Templates: Schemas for automatic index creation"]
        L4["Coordinator: Routes requests and aggregates results"]
    end
    
    style DP fill:#e3f2fd
    style LS fill:#e8f5e9
    style WIC fill:#f3e5f5
    style DC fill:#fff3e0
    style Legend fill:#fce4ec
    style Coordinator fill:#b39ddb
    style DN1 fill:#90caf9
    style DN2 fill:#90caf9
    style DN3 fill:#90caf9
    style FB fill:#a5d6a7
    style Templates fill:#ce93d8
    style Indices fill:#ce93d8
    
```

---

## 10. Practical Examples

### 10.1 Complete Example: From Real Alert to Storage

#### Scenario: SSH Brute Force Attack Attempt

**1. Original Event (in /var/log/auth.log)**

```
Oct 19 14:30:45 web-server-01 sshd[12345]: Failed password for root from 203.0.113.45 port 54321 ssh2
Oct 19 14:30:47 web-server-01 sshd[12346]: Failed password for root from 203.0.113.45 port 54322 ssh2
Oct 19 14:30:49 web-server-01 sshd[12347]: Failed password for root from 203.0.113.45 port 54323 ssh2
Oct 19 14:30:51 web-server-01 sshd[12348]: Failed password for root from 203.0.113.45 port 54324 ssh2
Oct 19 14:30:53 web-server-01 sshd[12349]: Failed password for root from 203.0.113.45 port 54325 ssh2
```

**2. Wazuh Agent Reads Event**

```xml
<!-- In ossec.conf -->
<localfile>
  <log_format>syslog</log_format>
  <location>/var/log/auth.log</location>
</localfile>
```

**3. Manager Analyzes and Applies Rule**

```xml
<!-- Rule 5551 -->
<rule id="5551" level="10" frequency="5" timeframe="120">
  <if_matched_sid>5503</if_matched_sid>
  <description>Multiple authentication failures</description>
  <mitre>
    <id>T1110</id>
  </mitre>
  <group>authentication_failures,</group>
</rule>
```

**4. Manager Writes Alert**

```json
{
  "timestamp": "2025-10-19T14:30:53.456+0000",
  "rule": {
    "level": 10,
    "description": "Multiple authentication failures",
    "id": "5551",
    "mitre": {
      "id": ["T1110"],
      "tactic": ["Credential Access"],
      "technique": ["Brute Force"]
    },
    "firedtimes": 5,
    "mail": true,
    "groups": ["authentication_failures", "syslog", "sshd"]
  },
  "agent": {
    "id": "001",
    "name": "web-server-01",
    "ip": "192.168.1.100",
    "version": "Wazuh v4.8.0"
  },
  "manager": {
    "name": "wazuh-manager"
  },
  "id": "1697724653.45678",
  "decoder": {
    "parent": "sshd",
    "name": "sshd"
  },
  "data": {
    "srcip": "203.0.113.45",
    "srcport": "54325",
    "dstuser": "root"
  },
  "location": "/var/log/auth.log",
  "full_log": "Failed password for root from 203.0.113.45 port 54325 ssh2"
}
```

**5. Filebeat Reads and Sends**

```
[2025-10-19T14:30:54] INFO Harvester started for file: /var/ossec/logs/alerts/alerts.json
[2025-10-19T14:30:54] INFO Read 1 lines from /var/ossec/logs/alerts/alerts.json
[2025-10-19T14:30:54] INFO Added event to batch
[2025-10-19T14:30:55] INFO Batch full (2000 events), publishing...
[2025-10-19T14:30:55] INFO POST https://indexer:9200/_bulk (428 KB)
```

**6. Indexer Indexes**

```json
POST /_bulk
Content-Type: application/x-ndjson

{"index":{"_index":"wazuh-alerts-4.x-2025.10.19","_id":"1697724653.45678"}}
{"@timestamp":"2025-10-19T14:30:53.456Z","rule":{"level":10,"description":"Multiple authentication failures","id":"5551","mitre":{"id":["T1110"],"tactic":["Credential Access"],"technique":["Brute Force"]}},"agent":{"id":"001","name":"web-server-01","ip":"192.168.1.100"},"data":{"srcip":"203.0.113.45","dstuser":"root"},"location":"/var/log/auth.log"}
```

**7. Indexer Response**

```json
{
  "took": 45,
  "errors": false,
  "items": [
    {
      "index": {
        "_index": "wazuh-alerts-4.x-2025.10.19",
        "_id": "1697724653.45678",
        "_version": 1,
        "result": "created",
        "_shards": {
          "total": 2,
          "successful": 2,
          "failed": 0
        },
        "_seq_no": 12345,
        "_primary_term": 1,
        "status": 201
      }
    }
  }
}
```

**8. Now Alert is Stored and Searchable**

### 10.2 Complete Example: Search and Query

#### Scenario: Search for All SSH Attacks in Last 24 Hours

**1. Request from Dashboard**

```http
POST /wazuh-alerts-*/_search
Content-Type: application/json
Authorization: Basic YWRtaW46cGFzc3dvcmQ=

{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "rule.groups": "sshd"
          }
        },
        {
          "range": {
            "rule.level": {
              "gte": 7
            }
          }
        },
        {
          "range": {
            "@timestamp": {
              "gte": "now-24h"
            }
          }
        }
      ]
    }
  },
  "aggs": {
    "attacks_by_source": {
      "terms": {
        "field": "data.srcip",
        "size": 10
      },
      "aggs": {
        "targeted_users": {
          "terms": {
            "field": "data.dstuser",
            "size": 5
          }
        }
      }
    },
    "timeline": {
      "date_histogram": {
        "field": "@timestamp",
        "fixed_interval": "1h"
      }
    }
  },
  "size": 100,
  "sort": [
    {
      "@timestamp": "desc"
    }
  ],
  "_source": [
    "rule.id",
    "rule.description",
    "rule.level",
    "@timestamp",
    "agent.name",
    "data.srcip",
    "data.dstuser"
  ]
}
```

**2. Indexer Response**

```json
{
  "took": 127,
  "timed_out": false,
  "_shards": {
    "total": 9,
    "successful": 9,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total": {
      "value": 342,
      "relation": "eq"
    },
    "max_score": null,
    "hits": [
      {
        "_index": "wazuh-alerts-4.x-2025.10.19",
        "_id": "1697724653.45678",
        "_score": null,
        "_source": {
          "@timestamp": "2025-10-19T14:30:53.456Z",
          "rule": {
            "id": "5551",
            "description": "Multiple authentication failures",
            "level": 10
          },
          "agent": {
            "name": "web-server-01"
          },
          "data": {
            "srcip": "203.0.113.45",
            "dstuser": "root"
          }
        },
        "sort": [1697724653456]
      },
      {
        "_index": "wazuh-alerts-4.x-2025.10.19",
        "_id": "1697720123.12345",
        "_score": null,
        "_source": {
          "@timestamp": "2025-10-19T13:15:23.123Z",
          "rule": {
            "id": "5551",
            "description": "Multiple authentication failures",
            "level": 10
          },
          "agent": {
            "name": "db-server-02"
          },
          "data": {
            "srcip": "198.51.100.87",
            "dstuser": "admin"
          }
        },
        "sort": [1697720123123]
      }
    ]
  },
  "aggregations": {
    "attacks_by_source": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 12,
      "buckets": [
        {
          "key": "203.0.113.45",
          "doc_count": 45,
          "targeted_users": {
            "buckets": [
              {"key": "root", "doc_count": 30},
              {"key": "admin", "doc_count": 10},
              {"key": "ubuntu", "doc_count": 5}
            ]
          }
        },
        {
          "key": "198.51.100.87",
          "doc_count": 28,
          "targeted_users": {
            "buckets": [
              {"key": "admin", "doc_count": 20},
              {"key": "postgres", "doc_count": 8}
            ]
          }
        }
      ]
    },
    "timeline": {
      "buckets": [
        {"key_as_string": "2025-10-19T10:00:00.000Z", "key": 1697709600000, "doc_count": 23},
        {"key_as_string": "2025-10-19T11:00:00.000Z", "key": 1697713200000, "doc_count": 45},
        {"key_as_string": "2025-10-19T12:00:00.000Z", "key": 1697716800000, "doc_count": 67},
        {"key_as_string": "2025-10-19T13:00:00.000Z", "key": 1697720400000, "doc_count": 89},
        {"key_as_string": "2025-10-19T14:00:00.000Z", "key": 1697724000000, "doc_count": 118}
      ]
    }
  }
}
```

**3. Dashboard Displays Results**

- **Total Attacks**: 342 in 24 hours
- **Most Dangerous IP**: 203.0.113.45 (45 attempts)
- **Most Targeted User**: root (30 attempts)
- **Peak Attack Time**: 14:00 (118 attempts)

---

## 11. Challenges and Solutions

### 11.1 Common Challenges

#### 11.1.1 Slow Indexing Performance

**Problem**: Low indexing throughput

**Causes**:
- Inappropriate number of shards
- Refresh interval too short
- Resource shortage (CPU/Memory/Disk)

**Solutions**:
```json
{
  "settings": {
    "index": {
      "number_of_shards": 5,
      "refresh_interval": "30s",
      "translog.durability": "async",
      "translog.sync_interval": "30s"
    }
  }
}
```

#### 11.1.2 Storage Space Consumption

**Problem**: Indices consuming large storage space

**Solutions**:

**1. Enable Compression:**
```json
{
  "settings": {
    "index.codec": "best_compression"
  }
}
```

**2. Use Index State Management (ISM):**
```json
{
  "policy": {
    "description": "Wazuh alerts retention policy",
    "default_state": "hot",
    "states": [
      {
        "name": "hot",
        "actions": [],
        "transitions": [
          {
            "state_name": "warm",
            "conditions": {
              "min_index_age": "7d"
            }
          }
        ]
      },
      {
        "name": "warm",
        "actions": [
          {
            "replica_count": {"number_of_replicas": 0}
          },
          {
            "force_merge": {"max_num_segments": 1}
          }
        ],
        "transitions": [
          {
            "state_name": "delete",
            "conditions": {
              "min_index_age": "90d"
            }
          }
        ]
      },
      {
        "name": "delete",
        "actions": [
          {"delete": {}}
        ]
      }
    ]
  }
}
```

#### 11.1.3 Slow Search

**Problem**: Queries take a long time

**Solutions**:

**1. Use Smart Index Patterns:**
```json
// Instead of searching all indices
GET /wazuh-alerts-*/_search

// Search only specific time range
GET /wazuh-alerts-4.x-2025.10.{19,18,17}/_search
```

**2. Optimize Queries:**
```json
// Slow
{
  "query": {
    "wildcard": {
      "rule.description": "*brute*force*"
    }
  }
}

// Fast
{
  "query": {
    "match": {
      "rule.description": "brute force"
    }
  }
}
```

**3. Use Filters Instead of Queries When Scoring Not Needed:**
```json
{
  "query": {
    "bool": {
      "filter": [
        {"term": {"rule.level": 10}},
        {"range": {"@timestamp": {"gte": "now-1h"}}}
      ]
    }
  }
}
```

### 11.2 Best Practices

#### 11.2.1 Index Strategy Design

```
✅ DO:
- Use daily or weekly indices
- Name indices with clear pattern: wazuh-alerts-4.x-YYYY.MM.DD
- Use aliases to reference index groups

❌ DON'T:
- Don't use a single large index
- Don't use random names for indices
```

#### 11.2.2 Optimize Mappings

```json
{
  "mappings": {
    "properties": {
      // ✅ Use appropriate types
      "timestamp": {"type": "date"},
      "count": {"type": "integer"},
      "severity": {"type": "byte"},
      
      // ✅ Disable indexing for fields not used in search
      "full_log": {
        "type": "text",
        "index": false
      },
      
      // ✅ Use ignore_above for long keywords
      "url": {
        "type": "keyword",
        "ignore_above": 512
      }
    }
  }
}
```

#### 11.2.3 Cluster Sizing

**For Production Environment:**

| Component | Minimum | Recommended |
|-----------|---------|-------------|
| **Coordinator Nodes** | 2 | 3 |
| **Data Nodes** | 3 | 5+ |
| **CPU per Node** | 4 cores | 8+ cores |
| **RAM per Node** | 8 GB | 32+ GB |
| **Disk** | SSD | NVMe SSD |
| **Network** | 1 Gbps | 10 Gbps |

**JVM Heap Size:**
```bash
# In opensearch.yml or jvm.options
# Set heap = 50% of RAM (but don't exceed 32GB)
-Xms16g
-Xmx16g
```

---

## 12. Monitoring & Troubleshooting

### 12.1 Monitor Cluster Health

```bash
# Cluster health
GET /_cluster/health

{
  "cluster_name": "wazuh-cluster",
  "status": "green",  # green = good, yellow = warning, red = error
  "timed_out": false,
  "number_of_nodes": 5,
  "number_of_data_nodes": 3,
  "active_primary_shards": 15,
  "active_shards": 30,
  "relocating_shards": 0,
  "initializing_shards": 0,
  "unassigned_shards": 0
}
```

### 12.2 Index Statistics

```bash
# Size of each index
GET /_cat/indices/wazuh-alerts-*?v&h=index,docs.count,store.size&s=index:desc

index                          docs.count store.size
wazuh-alerts-4.x-2025.10.19      1234567   2.3gb
wazuh-alerts-4.x-2025.10.18      1198234   2.1gb
wazuh-alerts-4.x-2025.10.17      1156789   2.0gb
```

### 12.3 Query Performance

```bash
# Enable slow query logging
PUT /wazuh-alerts-*/_settings
{
  "index.search.slowlog.threshold.query.warn": "10s",
  "index.search.slowlog.threshold.query.info": "5s",
  "index.search.slowlog.threshold.fetch.warn": "1s"
}
```

### 12.4 Troubleshooting

#### Issue: Unassigned Shards

```bash
# Identify the cause
GET /_cluster/allocation/explain

# Potential solution: Retry assignment
POST /_cluster/reroute?retry_failed=true
```

#### Issue: Circuit Breaker

```bash
# Increase memory circuit breaker limit
PUT /_cluster/settings
{
  "persistent": {
    "indices.breaker.total.limit": "80%"
  }
}
```

---

## 13. Conclusion

### 13.1 Quick Summary

**Wazuh Indexer** is the backbone of data storage and retrieval in the Wazuh EDR system:

1. **Reception**: Receives alerts from Manager via Filebeat
2. **Indexing**: Applies Templates and Mappings to organize data
3. **Storage**: Distributes data across Shards for performance and reliability
4. **Search**: Provides fast, powerful queries with advanced aggregations
5. **Integration**: Connects with Dashboard and API for data display

### 13.2 Key Components

| Component | Purpose | Importance |
|-----------|---------|-----------|
| **Index Templates** | Index creation templates | ⭐⭐⭐⭐⭐ |
| **Mappings** | Data schema definition | ⭐⭐⭐⭐⭐ |
| **Shards** | Data distribution | ⭐⭐⭐⭐ |
| **Replicas** | Backup copies | ⭐⭐⭐⭐ |
| **Query DSL** | Query language | ⭐⭐⭐⭐⭐ |
| **Aggregations** | Statistical analysis | ⭐⭐⭐⭐ |

### 13.3 Importance of Indexer in System

```
Without Indexer:
❌ Cannot search past events
❌ Cannot analyze security trends
❌ Cannot generate compliance reports
❌ Cannot perform forensic investigation

With Indexer:
✅ Fast search in millions of events (< 100ms)
✅ Real-time analysis
✅ Retain data for months/years
✅ Detailed reports and statistics
✅ Complex and flexible queries
```

### 13.4 Next Steps (for Advanced Learning)

1. **Deep Dive into Query DSL**: 
   - https://opensearch.org/docs/latest/query-dsl/

2. **Master Aggregations**:
   - https://opensearch.org/docs/latest/aggregations/

3. **Performance Optimization**:
   - https://opensearch.org/docs/latest/tuning-your-cluster/

4. **Index State Management**:
   - https://opensearch.org/docs/latest/im-plugin/ism/index/

5. **Security Configuration**:
   - https://opensearch.org/docs/latest/security/

---

## 14. References and Resources

### 14.1 Official Documentation

**Wazuh:**
- Architecture: https://documentation.wazuh.com/current/getting-started/architecture.html
- Indexer Setup: https://documentation.wazuh.com/current/installation-guide/wazuh-indexer/index.html
- Index Management: https://documentation.wazuh.com/current/user-manual/elasticsearch/elastic-tuning.html

**OpenSearch:**
- Getting Started: https://opensearch.org/docs/latest/getting-started/
- Index APIs: https://opensearch.org/docs/latest/api-reference/index-apis/
- Search APIs: https://opensearch.org/docs/latest/api-reference/search/
- Mappings: https://opensearch.org/docs/latest/field-types/mappings/
- Query DSL: https://opensearch.org/docs/latest/query-dsl/

### 14.2 Source Code

- Wazuh Indexer: https://github.com/wazuh/wazuh-indexer
- Wazuh Main: https://github.com/wazuh/wazuh
- OpenSearch: https://github.com/opensearch-project/OpenSearch

### 14.3 Useful Tools

- Wazuh Documentation: https://documentation.wazuh.com/
- OpenSearch Playground: https://playground.opensearch.org/
- Elastic Common Schema: https://www.elastic.co/guide/en/ecs/current/index.html

---

## 15. Appendix: Technical Terminology

| Term | Explanation |
|------|-------------|
| **Index** | A collection of documents stored together |
| **Document** | Basic unit of data (like a JSON object) |
| **Shard** | A portion of an index distributed across a node |
| **Replica** | A backup copy of a shard |
| **Node** | A single server in the cluster |
| **Cluster** | A group of nodes working together |
| **Mapping** | Schema definition for documents |
| **Template** | Blueprint for creating new indices |
| **Analyzer** | Text analyzer (tokenization) |
| **Aggregation** | Grouping and statistical operation |
| **Query DSL** | JSON query language |
| **Inverted Index** | Lucene data structure for fast search |
| **Refresh** | Making new documents searchable |
| **Flush** | Writing data from memory to disk |

---

## 16. Acknowledgments

This report was prepared as part of the **Wazuh EDR** understanding and documentation project, aimed at transforming complex code into clear and simplified knowledge.

**Project Team:**
- Server/Manager: Omar
- Agent: Saleh + Ziyad
- Dashboard: Abdulhamid
- Indexer: [Name Hidden]
- Research Paper: Abdulkhaliq

**Date of Preparation**: October 2025
**Version**: 1.0

---

## 17. Final Notes

### For Readers of This Report:

This report focuses on **Wazuh Indexer** only, which is part of a larger ecosystem. To understand the complete picture, it's recommended to read other reports about:
- **Manager**: How events are analyzed and alerts generated
- **Agent**: How events are collected from devices
- **Dashboard**: How data is displayed to users

### Strengths of This Report:

✅ Detailed explanation of Index Templates and Mappings  
✅ Real-world practical examples from start to finish  
✅ Comprehensive illustrative diagrams  
✅ Complete coverage of indexing and search processes  
✅ Best practices and performance optimization tips  
✅ Direct links to official sources  

### For Questions or Improvements:

This report is open to updates and improvements. If you find any errors or have suggestions, please:
1. Review official documentation to verify
2. Contact the team
3. Contribute to improving the report

---

**EOF - End of Report**

```
╔══════════════════════════════════════════════════════════╗
║    Completed - Wazuh Indexer Report Finished            ║
║                                                          ║
║    "Knowledge is power, and good documentation makes    ║
║     it accessible to everyone"                          ║
╚══════════════════════════════════════════════════════════╝
```